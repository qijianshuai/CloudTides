/**
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { __decorate, __param } from "tslib";
import { Component, ContentChild, Inject, InjectionToken } from '@angular/core';
import { BehaviorSubject, Subscription } from 'rxjs';
import { ControlIdService } from '../common/providers/control-id.service';
import { ClrLabel } from '../common/label';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '../common/label';
import * as ɵngcc3 from 'rxjs';

function ClrCheckboxWrapper_label_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "label");
} }
var _c0 = [[["", "clrCheckbox", ""], ["", "clrToggle", ""]], [["label"]]];
var _c1 = ["[clrCheckbox],[clrToggle]", "label"];
export var IS_TOGGLE = new InjectionToken('IS_TOGGLE');
export function isToggleFactory() {
    return new BehaviorSubject(false);
}
export var IS_TOGGLE_PROVIDER = { provide: IS_TOGGLE, useFactory: isToggleFactory };
var ClrCheckboxWrapper = /** @class */ (function () {
    function ClrCheckboxWrapper(toggleService) {
        var _this = this;
        // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
        // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
        // but we'd still need to insert a label
        this._dynamic = false;
        this.toggle = false;
        this.subscriptions = [];
        this.subscriptions.push(toggleService.subscribe(function (state) {
            _this.toggle = state;
        }));
    }
    ClrCheckboxWrapper.prototype.ngOnInit = function () {
        if (this.label) {
            this.label.disableGrid();
        }
    };
    ClrCheckboxWrapper.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrCheckboxWrapper.ctorParameters = function () { return [
        { type: BehaviorSubject, decorators: [{ type: Inject, args: [IS_TOGGLE,] }] }
    ]; };
    __decorate([
        ContentChild(ClrLabel, { static: true })
    ], ClrCheckboxWrapper.prototype, "label", void 0);
    ClrCheckboxWrapper = __decorate([ __param(0, Inject(IS_TOGGLE))
    ], ClrCheckboxWrapper);
ClrCheckboxWrapper.ɵfac = function ClrCheckboxWrapper_Factory(t) { return new (t || ClrCheckboxWrapper)(ɵngcc0.ɵɵdirectiveInject(IS_TOGGLE)); };
ClrCheckboxWrapper.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ClrCheckboxWrapper, selectors: [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]], contentQueries: function ClrCheckboxWrapper_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, ClrLabel, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
    } }, hostVars: 4, hostBindings: function ClrCheckboxWrapper_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("clr-checkbox-wrapper", !ctx.toggle)("clr-toggle-wrapper", ctx.toggle);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ControlIdService, IS_TOGGLE_PROVIDER])], ngContentSelectors: _c1, decls: 3, vars: 1, consts: [[4, "ngIf"]], template: function ClrCheckboxWrapper_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵtemplate(2, ClrCheckboxWrapper_label_2_Template, 1, 0, "label", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.label);
    } }, directives: [ɵngcc1.NgIf, ɵngcc2.ClrLabel], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClrCheckboxWrapper, [{
        type: Component,
        args: [{
                selector: 'clr-checkbox-wrapper,clr-toggle-wrapper',
                template: "\n    <ng-content select=\"[clrCheckbox],[clrToggle]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                host: {
                    '[class.clr-checkbox-wrapper]': '!toggle',
                    '[class.clr-toggle-wrapper]': 'toggle'
                },
                providers: [ControlIdService, IS_TOGGLE_PROVIDER]
            }]
    }], function () { return [{ type: ɵngcc3.BehaviorSubject, decorators: [{
                type: Inject,
                args: [IS_TOGGLE]
            }] }]; }, { label: [{
            type: ContentChild,
            args: [ClrLabel, { static: true }]
        }] }); })();
    return ClrCheckboxWrapper;
}());
export { ClrCheckboxWrapper };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3gtd3JhcHBlci5qcyIsInNvdXJjZXMiOlsibmc6L0BjbHIvYW5ndWxhci9mb3Jtcy9jaGVja2JveC9jaGVja2JveC13cmFwcGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBVSxZQUFZLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNuRyxPQUFPLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUdyRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUMxRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7Ozs7O0FBRTNDLE1BQU0sQ0FBQyxJQUFNLFNBQVMsR0FBRyxJQUFJLGNBQWMsQ0FBMkIsV0FBVyxDQUFDLENBQUM7QUFDbkYsTUFBTSxVQUFVLGVBQWU7QUFDL0IsSUFBRSxPQUFPLElBQUksZUFBZSxDQUFVLEtBQUssQ0FBQyxDQUFDO0FBQzdDLENBQUM7QUFDRCxNQUFNLENBQUMsSUFBTSxrQkFBa0IsR0FBRyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxDQUFDO0FBZXRGO0FBQXNELElBVXBELDRCQUErQixhQUF1QztBQUN4RSxRQURFLGlCQU1DO0FBQ0gsUUFoQkUsa0ZBQWtGO0FBQ3BGLFFBQUUsc0ZBQXNGO0FBQ3hGLFFBQUUsd0NBQXdDO0FBQzFDLFFBQUUsYUFBUSxHQUFHLEtBQUssQ0FBQztBQUNuQixRQUVFLFdBQU0sR0FBRyxLQUFLLENBQUM7QUFDakIsUUFBVSxrQkFBYSxHQUFtQixFQUFFLENBQUM7QUFDN0MsUUFFSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDckIsYUFBYSxDQUFDLFNBQVMsQ0FBQyxVQUFBLEtBQUs7QUFBSSxZQUMvQixLQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztBQUM1QixRQUFNLENBQUMsQ0FBQyxDQUNILENBQUM7QUFDTixJQUFFLENBQUM7QUFDSCxJQUNFLHFDQUFRLEdBQVI7QUFDRCxRQUFHLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNwQixZQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDL0IsU0FBSztBQUNMLElBQUUsQ0FBQztBQUVILElBQUUsd0NBQVcsR0FBWDtBQUFjLFFBQ1osSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQSxHQUFHLElBQUksT0FBQSxHQUFHLENBQUMsV0FBVyxFQUFFLEVBQWpCLENBQWlCLENBQUMsQ0FBQztBQUN6RCxJQUFFLENBQUM7QUFDRjtBQUM2RCxnQkFsQmQsZUFBZSx1QkFBaEQsTUFBTSxTQUFDLFNBQVM7QUFBUTtBQUFVLElBSi9DO0FBQWEsUUFEWixZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDO0FBQzNDLHFEQUFrQjtBQUNqQixJQVBZLGtCQUFrQix3QkFiOUIsU0FBUyxDQUFDLG5CQWFILENBVU8sV0FBQSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUE7RUF0QjlCLFFBQVEsRUFBRSxaQXNCcUIsT0FWcEIsa0JBQWtCLENBMkI5Qjt5QkF2Q29ELGNBQ25ELFFBQVEsRUFBRTtnRUFJVCxjQUNELElBQUksRUFBRSxrQkFDSiw4QkFBOEIsRUFBRSxTQUFTLGtCQUN6Qyw0QkFBNEIsRUFBRSxRQUFRLGVBQ3ZDLGNBQ0Q7Q0FBUyxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsa0JBQWtCLENBQUMsVUFDbEQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBNkJGO0FBQUMsSUFERCx5QkFBQztBQUNBLENBREEsQUEzQkQsSUEyQkM7QUFDRCxTQTVCYSxrQkFBa0I7QUFBSSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBDb250ZW50Q2hpbGQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5leHBvcnQgY29uc3QgSVNfVE9HR0xFID0gbmV3IEluamVjdGlvblRva2VuPEJlaGF2aW9yU3ViamVjdDxib29sZWFuPj4oJ0lTX1RPR0dMRScpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVG9nZ2xlRmFjdG9yeSgpIHtcbiAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xufVxuZXhwb3J0IGNvbnN0IElTX1RPR0dMRV9QUk9WSURFUiA9IHsgcHJvdmlkZTogSVNfVE9HR0xFLCB1c2VGYWN0b3J5OiBpc1RvZ2dsZUZhY3RvcnkgfTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNoZWNrYm94LXdyYXBwZXIsY2xyLXRvZ2dsZS13cmFwcGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyQ2hlY2tib3hdLFtjbHJUb2dnbGVdXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbFwiPjwvbGFiZWw+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1jaGVja2JveC13cmFwcGVyXSc6ICchdG9nZ2xlJyxcbiAgICAnW2NsYXNzLmNsci10b2dnbGUtd3JhcHBlcl0nOiAndG9nZ2xlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbQ29udHJvbElkU2VydmljZSwgSVNfVE9HR0xFX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hXcmFwcGVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLy8gV2UgbmVlZCBib3RoIF9keW5hbWljIGZvciBIb3N0V3JhcHBlciBhbmQgQ29udGVudENoaWxkKENsckxhYmVsKSBpbiBjYXNlcyB3aGVyZVxuICAvLyB0aGUgdXNlciBwdXRzIGEgcmFkaW8gaW5zaWRlIGEgd3JhcHBlciB3aXRob3V0IGEgbGFiZWwsIGhvc3Qgd3JhcHBpbmcgZG9lc24ndCBhcHBseVxuICAvLyBidXQgd2UnZCBzdGlsbCBuZWVkIHRvIGluc2VydCBhIGxhYmVsXG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwsIHsgc3RhdGljOiB0cnVlIH0pXG4gIGxhYmVsOiBDbHJMYWJlbDtcbiAgdG9nZ2xlID0gZmFsc2U7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KElTX1RPR0dMRSkgdG9nZ2xlU2VydmljZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0b2dnbGVTZXJ2aWNlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlID0gc3RhdGU7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbC5kaXNhYmxlR3JpZCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiJdfQ==